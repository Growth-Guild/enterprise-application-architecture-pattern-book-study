# Chapter 13. 객체-관계형 메타데이터 매핑 패턴
- - -

## 메타데이터 매핑
* 메타데이터 매핑은 매핑을 간단한 표 형식으로 정의하고 범용 코드를 통해 이를 처리함으로써 데이터 읽기, 삽입, 업데이트를 수행하는 방식이다.

### 작동 원리
* 메타데이터 매핑을 사용할 때는 코드 생성과 리플렉션 프로그래밍 방식이 있다.
* 코드 생성 방식에서는 메타데이터를 입력으로 받고 매핑을 수행하는 클래스의 소스코드를 출력하는 프로그램을 작성한다.
  * 일반적으로 컴파일 전에 빌드 프로세스 중 완전하게 생성된다.
  * 결과 매퍼 클래스는 서버 코드와 함께 배포되며, 현재 사용 중인 빌드 스크립트를 빌드 프로세스에 완전하게 통합하는 것이 중요하다.
  * 매핑을 조금이라도 변경하면 적어도 소프트웨어의 일부를 다시 컴파일하고 배포해야 하므로 유연성이 낮다.
* 리플렉션 프로그램 방식에서는 메서드와 필드를 데이터로 취급해 메타데이터 파일에서 필드와 메서드 이름을 읽고 이 정보를 기준으로 매핑한다.
  * 디버그하기가 어렵다는 단점이 있다.
  * 매핑 데이터 파일만 변경하면 기존 클래스가 새로운 메타데이터를 사용한다.
* 대부분의 경우 메타데이터는 별도의 파일 형식으로 저장한다.
  * XML은 계층 구조를 제공하며 직접 파서나 다른 툴을 만들지 않고도 이용할 수 있기 때문에 가장 인기 있는 방법이다.
  * 로딩 단계에서는 XML로 기록된 메타데이터를 읽고 이를 코드 생성 출력이나 리플렉션 매핑에 활용할 프로그래밍 언어 구조로 변환한다.
* 코드 생성 방식에서는 읽고 구문 분석하는 작업이 실행 중이 아닌 빌드 중에 수행된다.
* 리플렉션 프로그래밍 방식에서는 읽고 구문 분석하는 작업이 주로 실행 중 수행되지만 시스템 시작 시 한 번만 수행되며 이후에는 메모리에 저장된 표현을 사용한다.

### 사용 시점
* 메타데이터 매핑을 사용하면 데이터베이스 매핑 작업을 크게 간소화할 수 있다.
* 거의 모든 상황을 메타데이터 매핑으로 처리할 수 있지만 메타데이터를 아주 복잡하게 만드는 에외 상황이 있다.
* 계층 상위 형식을 만들고 공통적인 동작을 모두 처리하게 하면 작성해야 하는 코드의 양을 크게 줄일 수 있다.
* 메타데이터 매핑을 사용하면 리팩터링이 어려울 수 잇으며, 특히 자동화된 툴을 사용하는 경우 문제가 더 복잡하다.
  * 반면 메타데이터 매핑을 사용하면 메타데이터가 데이터베이스 스키마의 인터페이스를 나타내므로 데이터베이스 리팩터링이 더 쉬워질 수 있다. 즉, 데이터베이스에 대한 변경 사항을 메타 데이터 매핑을 편집해 해결할 수 있다.

## 쿼리 객체
* 쿼리 객체는 인터프리터 역할을 한다. 객체의 구조를 바탕으로 SQL 쿼리를 구성할 수 있게 해준다.
* 쿼리를 생성할 때는 테이블과 열이 아닌 클래스와 필드를 참조한다.
* 데이터베이스 스키마에 의존하지 않고 쿼리를 작성할 ㅅ ㅜ있으며, 스키마에 대한 변경 사항을 한곳에서 처리할 수 있다.

### 작동 원리
* 쿼리 객체는 SQL 쿼리를 표현하기 위해 설계된 인터프리터 패턴을 활용한 것이다.
* 쿼리 객체의 주된 역할은 클라이언트가 객체 구조를 활용해 다양한 종류의 쿼리를 구성하면 이러한 구조를 해당하는 SQL 문자열로 변환하는 것이다.
* 쿼리 객체는 데이터베이스 구조가 객체 구조에 어떻게 매핑되는지 알아야 하므로 메타데이터 매핑이 필요하다.

### 사용 시점
* 쿼리 객체는 구현하기 상당히 복잡한 패턴이므로 직접 작성한 데이터 원본 계층이 있는 프로젝트에서는 대부분 쿼리 객체를 사용하지 않는다.
* 쿼리 객체는 도메인 모델과 데이터 매퍼를 사용할 때만 필요하며, 제대로 활용하려면 메타데이터 매핑도 함께 사용해야 한다.
* 쿼리 객체의 장점은 데이터베이스 스키마 캡슐화, 다중 데이터베이스 지원, 다중 스키마 지원, 중복 쿼리 방지 등과 같은 복잡한 요건을 충족할 수 있다는 점이다.

## 리포지토리
* 리포지토리는 도메인과 데이터 매핑 계층 사이를 중재해 인메모리 도메인 객체 컬렉션과 비슷하게 작동한다.
* 객체의 간단한 컬렉션과 마찬가지로 리포지토리에도 객체를 추가하거나 제거할 수 있으며, 리포지토리에 의해 캡슐화되는 매핃코드가 적절한 작업을 내부적으로 처리한다.
* 리포지토리는 데이터 저장소에 저장된 객체의 집합과 이를 대상으로 수행하는 작업을 개념상으로 캡슐화해 지속성 계층에 대한 좀 더 객체지향적 관점을 제공한다.
* 리포지토리는 도메인과 데이터 매핑 계층 간의 깔끔한 분리와 단방향 의존성의 목표를 달성하도록 지원한다.

### 작동 원리
* 리포지토리는 내부적으로는 상당히 복잡하고 정교하지만 겉으로는 간단한 인터페이스다.
* 리포지토리를 사용하는 코드는 도메인 객체로 이뤄진 간단한 인메모리 컬렉션을 사용하는 코드와 비슷해 보이며, 도메인 객체는 일반적으로 리포지토리 안에 직접 저장되지 않으므로 클라이언트 코드로 노출되지 않는다.
* 리포지토리를 사용할 때는 클라이언트 코드의 관점에서 쿼리 "실행"이라는 개념이 없으며, 쿼리 사양을 "충족"하는 객체가 선택된다.
* 내부적으로 리포지토리는 메타데이터 매핑과 쿼리 객체를 결합해 자동으로 조건을 기준으로 SQL 코드를 생성한다.
* 여러 데이터베이스 스키마나 도메인 객체의 원본을 사용하는 시스템은 물론, 테스트 중에 속도를 높이기 위해 인메모리 객체만 사용하는 경우에도 리포지토리는 많은 도움이 된다.

### 사용 시점
* 리포지토리는 쿼리를 순수한 객체지향 방식으로 수행할 수 있게 캡슐화하는 사양 해턴을 촉진한다.
* 단위 테스트 집합을 실행할 때 성능을 위해 완전히 메모리 안에서 실행할 때와 같이 간단한 인메모리 데이터 저장소를 사용할 환경을 준비하는 과정이 간소해진다.
