# Chapter 05. 동시성
- - -

* 동시성 문제를 해결하기 위한 어려운 이유는 문제의 모든 원인을 미리 알기 어렵기 때문이다.
* 동시성은 테스트하기 어렵다.
  * 자동화 테스트는 소프트웨어 개발의 기반으로서 중요한 역할을 하지만 동시성 문제를 확실하게 해결할 수 있는 테스트를 만들기는 어렵다.
* 트랜잭션 관리자는 엔터프라이즈 애플리케이션에서 가장 까다로운 동시성의 여러 측면을 예방하는 프레임워크를 제공하며, 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다.
* 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우 개발자가 직접 동시성을 관리해야 하는데, 여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성 제어를 오프라인 동시성이라고 한다.

## 동시성 문제
* 손실된 업데이트
  * A 사용자가 정보를 수정하는 동안 B가 뒤늦게 수정을 시작해서 A보다 먼저 끝낸 경우, A가 수정을 완료하면 B의 수정 내용이 손실된다.
* 일관성 없는 읽기
  * A가 Foo 테이블과 Bar 테이블에서 읽기를 수행한다. (현재 Foo 테이블의 데이터 개수: 1, Bar 테이블의 데이터 개수: 1)
  * A가 Foo 테이블을 먼저 읽고, 잠시 다른 처리를 하는 사이에 B가 Foo 테이블에 2개, Bar 테이블에 3개 INSERT 한다. (현재 Foo 테이블의 데이터 개수: 3, Bar 테이블의 데이터 개수: 4)
  * A가 처리를 완료하고 이제 Bar 테이블을 읽으면 Foo 테이블에는 1개, Bar 테이블에는 4개가 존재하는 것처럼 보이게 된다. 
* 위와 같은 문제는 동시에 동일한 데이터를 사용하려고 하지 않는다면 발생하지 않는다.
  * 정확성만 중요하게 생각한다면 큰 문제가 없지만, 동시에 처리하는 능력은 저하된다.
* 모든 동시성 프로그래밍의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 한다.
  * 실패의 심각성과 발생 가능성, 여러 사람들이 동시에 데이터를 사용해야 하는 필요성을 감안해 트레이드 오프를 정하는 것이 중요하다.

## 격리와 불변성
* 동시성 문제는 프로세스나 스레드와 같은 활성 에이전트가 동시에 둘 이상 동일한 데이터에 접근할 때 발생한다.
* 이 문제를 해결하는 한 가지 방법은 격리를 통해 데이터를 분리하여 하나의 활성 에이전트만 데이터에 접근하게 하는 것이다.
* 격리는 오류 발생 가능성을 낮추는 필수 기법이다.
* 애플리케이션에서 데이터를 읽기만 하는 부분을 분리하고, 데이터의 복사본을 사용하게 하면 모든 동시성 제어로부터 자유롭게 작업할 수 있다.

## 낙관적 동시성 제어와 비관적 동시성 제어
* 낙관적 잠금 (optimistic locking)
  * 낙관적 잠금은 충돌 감지에 해당한다.
  * 낙관적 잠금은 데이터의 버전을 통해서 충돌이 발생했음을 감지한다.
* 비관적 잠금 (pessimistic locking)
  * 비관적 잠금은 충돌 예방에 해당한다.
  * 데이터를 수정할 경우에, 해당 로우에 잠금을 걸어서 다른 쓰레드가 데이터를 접근하지 못하도록 막는다.
* 오늘날 대부분의 개발자는 낙관적 잠금을 선호한다.
* 비관적 잠금의 단점은 동시성이 제한된다.
* 낙관적 잠금은 변경 사항을 제출할 때만 잠금이 적용하므로 동시에 접근이 가능하다.
* 낙관적 잠금과 비관적 잠금을 선택하는 가장 중요한 기준은 충돌의 빈도와 심각도다.
  * 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 더 나은 동시성을 제공하고 구현하기도 쉬운 낙관적 잠금을 선택해야 한다.
  * 그 반대의 경우에는 비관적 잠금을 사용해야 한다.

### 일관성 없는 읽기 예방
* 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 일관성 없는 읽기 문제를 해결할 수 있다.
* 데이터를 읽으려면 읽기(또는 공유된) 잠금이 필요하다.
* 데이터를 쓰려면 쓰기(또는 배타적) 잠금이 필요하다.
* 여러 사용자가 동시에 데이터에 읽기 잠금을 가질 수 있지만, 읽기 잠금을 가진 사용자가 있으면 다른 사용자는 쓰기 잠금을 가질 수 없다.
* 쓰기 잠금을 가진 사용자가 있으면 다른 사용자는 어떤 잠금도 가질 수 없다.
* 낙관적 잠금의 충돌 감지 기능은 일반적으로 데이터에 넣은 일종의 버전 표식을 기반으로 작동한다.
  * 버전에 차이가 있다면 충돌이 발생했다는 의미다.
* 임시 읽기(temporal read)를 이용하는 방법으로 일관성 없는 읽기를 예방할 수도 있다.
  * 읽은 모든 데이터에 일종의 타임스탬프나 읽기 전용 라벨을 붙이고, 데이터베이스는 이 시간이나 라벨을 기준으로 데이터를 반환한다.

### 교착 상태
* 교착 상태는 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.
* 교착 상태가 발생하면 감지할 수 있는 소프트웨어를 사용하여 해결할 수 있다.
  * 교착 상태가 발생하면 희생자 한 명을 선택해 해당 사용자의 작업과 잠금을 포기해 다른 사용자가 작업을 진행할 수 있게 한다.
  * 모든 잠금에 시간 제한을 두는 방식도 있다.
* 교착 상태가 아예 발생하지 않게 예방하는 기법도 있다.
  * 교착 상태는 기본적으로 이미 잠금을 가진 사용자가 다른 잠금을 얻으려고 할 때 (또는 읽기 잠금을 쓰기 잠금으로 업그레이드할 때) 발생한다.
  * 작업을 시작할 때 필요한 잠금을 모두 얻게 하고 추가 잠금을 얻지 못하게 하면 교착 상태를 예방할 수 있다.

## 트랜잭션
* 트랜잭션은 시작점과 끝점이 명확하게 정의된 일련의 작업이다.
* 모든 트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일 방시긍로 수행해야 한다.

### ACID
* 원자성 (Atomicity)
  * 트랜잭션의 경계 안에서 수행되는 각 작업의 단계는 모두 성공적으로 완료되거나 롤백돼야 한다.
* 일관성 (Consistency)
  * 시스템의 자원은 트랜잭션의 시작과 완료 시점에 모두 일관성 있고 손상되지 않은 상태여야 한다.
* 격리성 (Isolation)
  * 개별 트랜잭션의 결과는 트랜잭션이 성공적으로 커밋하기 전까지 다른 열여 있는 트랜잭션에서 볼 수 없어야 한다.
* 지속성 (Durability)
  * 커밋된 트랜잭션의 결과는 영구적이어야 한다.

### 트랜잭션 리소스
* 처리량을 극대화하기 위해서 최신 트랜잭션 시스템은 트랜잭션을 최대한 짧게 유지하도록 설계된다.
  * 따라서 여러 요청에 걸친 트랜잭션을 만들지 않도록 해야 한다.
* 트랜잭션을 최대한 늦게 여는 방법도 있다.
  * 하지만 트랜잭션을 시작하기 전까지 동시성 제어가 되지 않으므로 일관성 없는 읽기 문제의 우려가 있다.
* 트랜잭션을 사용할 때는 어떤 리소스가 잠기는지 어느 정도 인식하고 있어야 한다.
* 여러 데이터베이스 작업에서 트랜잭션 시스템은 작업과 관련된 행을 잠그므로 여러 트랜잭션이 동일한 테이블에 접근할 수 있다.
  * 이 경우에 트랜잭션이 테이블의 전체 행을 잠그는 경우 데이터베이스가 처리 가능한 수준 이상으로 잠금이 증가하고 결국 잠금이 상향되어 다른 트랜잭션까지 잠그게 된다.
  * 도메인의 계층 상위 형식 레벨의 데이터에 일부 객체 테이블을 사용하지 않아야 하는 이유이다.

### 활동성을 위한 트랜잭션 격리성 저하
* Serializable
  * 여러 트랜잭션을 동시에 실행해도 순서대로 실행했을 때와 동일한 결과를 얻을 수 있다.
  * 여러 요청을 반복했을 때 매번 동일한 결과를 보장하지는 않지만, 적어도 업데이트하기 전 또는 후의 결과를 보장한다.
* Repeatable read
  * Phantom read가 허용된다.
  * 팬텀 리드란 컬렉션에 여러 요소를 추가했을 때 읽는 쪽에서 일부 요소만 볼 수 있는 현상이다.
* Read committed
  * Unrepeatable read가 허용된다.
* Read uncommitted
  * Dirty read가 허용된다.
* 정확성을 최대한 보장하려면 항상 직렬화 가능 격리 수준을 사용해야 한다.
  * 하지만 시스템의 처리량이 크게 저하되므로 상황에 따라 트레이드 오프를 선택해야 한다.

### 비즈니스 트랜잭션과 시스템 트랜잭션
* RDBMS 시스템과 트랜잭션 모니터 등은 일반적으로 시스템 트랜잭션이다.
* 비즈니스 트랜잭션은 은행 시스템의 사용자가 로그인, 계정 선택, 이체 내역 설정, 확인 버튼을 눌러 금액을 이체하는 과정을 포함하는 것과 같은 범위의 트랜잭션이다. 
* 비즈니스 트랜잭션은 시스템 트랜잭션과 동일하게 ACID 속성을 제공해야 한다.
* 비즈니스 트랜잭션에서 ACID를 지원하는 방법은 시스템 트랜잭션 안에서 실행하는 것이다.
  * 하지만 비즈니스 트랜잭션은 여러 요청을 거치는 경우가 많으므로 시스템 트랜잭션 하나를 사용해 비즈니스 트랜잭션을 구현하면 긴 시스템 트랜잭션이 된다.
  * 긴 트랜잭션은 잘못 사용하면 데이터베이스가 주요 병목 구간이 되기 때문에 애플리케이션의 확장성이 제약을 받는다.
* 비즈니스 트랜잭션에서 적용하기 까다로운 ACID 속성은 격리다.
  * 격리의 실패는 일관성의 실패로 이어진다.
  * 애플리케이션이 단일 트랜잭션 안에서 일관성을 유지하기 위해 해야 하는 역할은 모든 사용 가능한 비즈니스 규칙을 적용하는 것이다.

### 오프라인 동시성 제어를 위한 패턴
* 가능하면 트랜잭션 시스템이 최대한 동시성 문제를 맡아서 처리하게 해야 한다.
* 오프라인 동시성을 처리하는 첫 번째 방법은 여러 비즈니스 트랜잭션에 걸쳐 낙관적 동시성 제어를 사용하는 낙관적 오프라인 잠금이다.
  * 낙관적 오프라인 잠금의 한계는 비즈니스 트랜잭션이 실패하는 경우 커밋할 때가 돼서야 알 수 있다는 것이다.
* 비관적 오프라인 잠금은 이에 대한 대안으로서 문제가 있으면 조기에 알아낼 수 있지만 프로그래밍하기 어렵고, 활동성이 제한된다.
* 암시적 잠금을 사용하면 애플리케이션 개발자의 부담을 크게 덜 수 있다.
  * 암시적 잠금을 사용하면 잠금을 직접 관리할 필요가 없다.
* 비관적 오프라인 잠금을 현명하게 설계하려면 시스템의 사용자에게서 도메인에 대한 정보를 충분히 얻어야 한다.
* 굵은 입자 잠금을 적절하게 선택하려면 도메인 지식이 필요하다.
