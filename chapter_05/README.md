# Chapter 05. 동시성
- - -

* 동시성 문제를 해결하기 위한 어려운 이유는 문제의 모든 원인을 미리 알기 어렵기 때문이다.
* 동시성은 테스트하기 어렵다.
  * 자동화 테스트는 소프트웨어 개발의 기반으로서 중요한 역할을 하지만 동시성 문제를 확실하게 해결할 수 있는 테스트를 만들기는 어렵다.
* 트랜잭션 관리자는 엔터프라이즈 애플리케이션에서 가장 까다로운 동시성의 여러 측면을 예방하는 프레임워크를 제공하며, 트랜잭션 내에서 모든 데이터 조작을 수행하면 심각한 문제는 대부분 예방할 수 있다.
* 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우 개발자가 직접 동시성을 관리해야 하는데, 여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성 제어를 오프라인 동시성이라고 한다.

## 동시성 문제
* 손실된 업데이트
  * A 사용자가 정보를 수정하는 동안 B가 뒤늦게 수정을 시작해서 A보다 먼저 끝낸 경우, A가 수정을 완료하면 B의 수정 내용이 손실된다.
* 일관성 없는 읽기
  * A가 Foo 테이블과 Bar 테이블에서 읽기를 수행한다. (현재 Foo 테이블의 데이터 개수: 1, Bar 테이블의 데이터 개수: 1)
  * A가 Foo 테이블을 먼저 읽고, 잠시 다른 처리를 하는 사이에 B가 Foo 테이블에 2개, Bar 테이블에 3개 INSERT 한다. (현재 Foo 테이블의 데이터 개수: 3, Bar 테이블의 데이터 개수: 4)
  * A가 처리를 완료하고 이제 Bar 테이블을 읽으면 Foo 테이블에는 1개, Bar 테이블에는 4개가 존재하는 것처럼 보이게 된다. 
* 위와 같은 문제는 동시에 동일한 데이터를 사용하려고 하지 않는다면 발생하지 않는다.
  * 정확성만 중요하게 생각한다면 큰 문제가 없지만, 동시에 처리하는 능력은 저하된다.
* 모든 동시성 프로그래밍의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며, 동시 작업이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 한다.
  * 실패의 심각성과 발생 가능성, 여러 사람들이 동시에 데이터를 사용해야 하는 필요성을 감안해 트레이드 오프를 정하는 것이 중요하다.

## 격리와 불변성
* 동시성 문제는 프로세스나 스레드와 같은 활성 에이전트가 동시에 둘 이상 동일한 데이터에 접근할 때 발생한다.
* 이 문제를 해결하는 한 가지 방법은 격리를 통해 데이터를 분리하여 하나의 활성 에이전트만 데이터에 접근하게 하는 것이다.
* 격리는 오류 발생 가능성을 낮추는 필수 기법이다.
* 애플리케이션에서 데이터를 읽기만 하는 부분을 분리하고, 데이터의 복사본을 사용하게 하면 모든 동시성 제어로부터 자유롭게 작업할 수 있다.

## 낙관적 동시성 제어와 비관적 동시성 제어
* 낙관적 잠금 (optimistic locking)
  * 낙관적 잠금은 충돌 감지에 해당한다.
  * 낙관적 잠금은 데이터의 버전을 통해서 충돌이 발생했음을 감지한다.
* 비관적 잠금 (pessimistic locking)
  * 비관적 잠금은 충돌 예방에 해당한다.
  * 데이터를 수정할 경우에, 해당 로우에 잠금을 걸어서 다른 쓰레드가 데이터를 접근하지 못하도록 막는다.
* 오늘날 대부분의 개발자는 낙관적 잠금을 선호한다.
* 비관적 잠금의 단점은 동시성이 제한된다.
* 낙관적 잠금은 변경 사항을 제출할 때만 잠금이 적용하므로 동시에 접근이 가능하다.
* 낙관적 잠금과 비관적 잠금을 선택하는 가장 중요한 기준은 충돌의 빈도와 심각도다.
  * 충돌이 자주 발생하지 않거나 그 결과가 그리 심각하지 않다면 더 나은 동시성을 제공하고 구현하기도 쉬운 낙관적 잠금을 선택해야 한다.
  * 그 반대의 경우에는 비관적 잠금을 사용해야 한다.

### 일관성 없는 읽기 예방
* 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 일관성 없는 읽기 문제를 해결할 수 있다.
* 데이터를 읽으려면 읽기(또는 공유된) 잠금이 필요하다.
* 데이터를 쓰려면 쓰기(또는 배타적) 잠금이 필요하다.
* 여러 사용자가 동시에 데이터에 읽기 잠금을 가질 수 있지만, 읽기 잠금을 가진 사용자가 있으면 다른 사용자는 쓰기 잠금을 가질 수 없다.
* 쓰기 잠금을 가진 사용자가 있으면 다른 사용자는 어떤 잠금도 가질 수 없다.
* 낙관적 잠금의 충돌 감지 기능은 일반적으로 데이터에 넣은 일종의 버전 표식을 기반으로 작동한다.
  * 버전에 차이가 있다면 충돌이 발생했다는 의미다.
* 임시 읽기(temporal read)를 이용하는 방법으로 일관성 없는 읽기를 예방할 수도 있다.
  * 읽은 모든 데이터에 일종의 타임스탬프나 읽기 전용 라벨을 붙이고, 데이터베이스는 이 시간이나 라벨을 기준으로 데이터를 반환한다.

### 교착 상태
* 교착 상태는 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.
* 교착 상태가 발생하면 감지할 수 있는 소프트웨어를 사용하여 해결할 수 있다.
  * 교착 상태가 발생하면 희생자 한 명을 선택해 해당 사용자의 작업과 잠금을 포기해 다른 사용자가 작업을 진행할 수 있게 한다.
  * 모든 잠금에 시간 제한을 두는 방식도 있다.
* 교착 상태가 아예 발생하지 않게 예방하는 기법도 있다.
  * 교착 상태는 기본적으로 이미 잠금을 가진 사용자가 다른 잠금을 얻으려고 할 때 (또는 읽기 잠금을 쓰기 잠금으로 업그레이드할 때) 발생한다.
  * 작업을 시작할 때 필요한 잠금을 모두 얻게 하고 추가 잠금을 얻지 못하게 하면 교착 상태를 예방할 수 있다.
