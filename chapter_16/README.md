# Chapter 16. 오프라인 동시성 패턴
- - -

## 낙관적 오프라인 잠금
* 두 세션이 동일한 레코드에 대한 작업을 수행하면 데이터 무결성이 위협을 받으며 업데이트 손실도 발생할 수 있다.
* 한 세션에서 편집 중인 데이터를 다른 세션에서 읽으면 일관성 없는 읽기도 발생할 수 있다.
* 낙관적 오프라인 잠금은 한 세션에서 커밋하려는 변경 내용이 다른 세션의 변경 내용과 충돌하지 않는지 확인하는 방법으로 이 문제를 해결한다.
* 유효성 검사와 업데이트가 단일 시스템 트랜잭션 내에서 수행되는 한 비즈니스 트랜잭션은 일관성을 유지한다.
* 충돌이 감지되면 트랜잭션을 롤백해 동시 비즈니스 트랜잭션 간의 충돌을 방지한다.
* 낙관적 오프라인 잠금은 동시성 충돌 가능성이 낮다고 간주하므로 여러 사용자가 동시에 동일한 데이터를 가지고 작업하도록 허용할 수 있다.

### 작동 원리
* 낙관적 오프라인 잠금은 세션이 레코드를 로드한 이후 다른 세션이 이를 변경하지 않은 것을 확인함으로써 획득할 수 있다.
  * 이 잠금은 언제든지 획득할 수 있지만 획득한 시스템 트랜잭션 안에서만 유효하다.
* 낙관적 오프라인 잠금을 구현하는 일반적인 방법은 각 레코드에 버전 번호를 연결하는 것이다.
  * 유효성 검사가 성공하면 버전 증가와 함께 레코드 데이터를 업데이트하게 된다.
  * 업데이트되는 행의 수가 0이면 충돌이 발생한 것이므로 해당 트랜잭션은 롤백하거나 문제를 해결한 후에 다시 시도해야 한다.
* 낙관적 검사에 버전 번호 대신 수정 타임스탬프를 사용하려는 것은 좋지 않다.
  * 시스템 클록은 신뢰할 수 없으며, 특히 여러 서버 간에 작업을 조율하는 경우 더욱 신뢰하기 어렵기 때문이다.
* 버저닝을 통한 낙관적 오프라인 잠금으로 일관성 없는 읽기의 문제가 완전히 해결되지는 않는다.
  * 청구서와 소비세를 계산하는 예시
    * A 세션이 청구서를 생성하고 세금을 계산하기 위해 해당 고객의 주소를 조회
    * A 세션이 고객의 주소를 조회하고 트랜잭션을 수행하는 동안 B 세션에서 해당 고객의 주소를 변경
    * 세율은 고객의 주소지에 따라 다른 경우에 A 세션은 고객의 주소를 변경하지 않았으므로 충돌은 감지되지 않고, 잘못된 세율이 계산됨
  * 위 예시의 문제를 해결하기 위해서는 고객의 주소 값이 중요하다는 것을 인식해야 한다.
  * 따라서 주소를 변경 집합에 추가하거나 버전 검사를 수행할 항목의 목록을 별도로 유지하는 등의 방법으로 주소에 대한 버전 검사를 수행해야 한다.
  * 만약 인공적인 업데이트가 아니라 버전을 다시 읽는 방법으로 일관된 읽기를 검사하는 경우 시스템 트랜잭션 격리 수준에 주의해야 한다.
  * 버전 다시 읽기는 반복 가능 읽기 이상의 경리 수준에서만 작동한다.
* 낙관적 오프라인 잠금만으로 비즈니스 애플리케이션의 모든 까다로운 동시성 또는 일시적 문제를 해결할 수 있는 것은 아니다.
  * 비즈니스 애플리케이션의 동시성 관리는 기술적 문제이기도 하지만 동시에 도메인 문제이기도 하다.
  * 두 세션이 동시에 컬렉션 항목에 추가할 경우에도 비즈니스 규칙을 위반할 가능성이 높다. 일반적인 낙관적 오프라인 잠금 체계에서는 이를 예방하지 못한다.

### 사용 시점
* 두 비즈니스 트랜잭션 간에 충돌이 발생할 가능성이 낮은 경우 유용하다.
* 충돌 가능성이 높거나 충돌의 결과를 받아들일 수 없는 경우 비관적 오프라인 잠금을 사용하는 것이 좋다.
* 낙관적 잠금은 구현하기가 훨씬 쉬우며 비관적 오프라인 잠금과 다르게 결함이나 런타임 오류에 취약하지 않으므로 모든 시스템의 비즈니스 트랜잭션 충돌을 관리하는 기본적인 방식으로 먼저 고려할 수 있다.
* 비관적 잠금은 낙관적 잠금을 보완하는 방식으로 잘 작동하므로 어떤 경우에 낙관적 잠금을 사용해 충돌을 방지할지 고려하기보다는 어떤 경우에 낙관적 잠금만으로는 부족한지 고려하는 것이 좋다.
