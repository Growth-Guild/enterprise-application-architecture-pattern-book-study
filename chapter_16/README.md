# Chapter 16. 오프라인 동시성 패턴
- - -

## 낙관적 오프라인 잠금
* 두 세션이 동일한 레코드에 대한 작업을 수행하면 데이터 무결성이 위협을 받으며 업데이트 손실도 발생할 수 있다.
* 한 세션에서 편집 중인 데이터를 다른 세션에서 읽으면 일관성 없는 읽기도 발생할 수 있다.
* 낙관적 오프라인 잠금은 한 세션에서 커밋하려는 변경 내용이 다른 세션의 변경 내용과 충돌하지 않는지 확인하는 방법으로 이 문제를 해결한다.
* 유효성 검사와 업데이트가 단일 시스템 트랜잭션 내에서 수행되는 한 비즈니스 트랜잭션은 일관성을 유지한다.
* 충돌이 감지되면 트랜잭션을 롤백해 동시 비즈니스 트랜잭션 간의 충돌을 방지한다.
* 낙관적 오프라인 잠금은 동시성 충돌 가능성이 낮다고 간주하므로 여러 사용자가 동시에 동일한 데이터를 가지고 작업하도록 허용할 수 있다.

### 작동 원리
* 낙관적 오프라인 잠금은 세션이 레코드를 로드한 이후 다른 세션이 이를 변경하지 않은 것을 확인함으로써 획득할 수 있다.
  * 이 잠금은 언제든지 획득할 수 있지만 획득한 시스템 트랜잭션 안에서만 유효하다.
* 낙관적 오프라인 잠금을 구현하는 일반적인 방법은 각 레코드에 버전 번호를 연결하는 것이다.
  * 유효성 검사가 성공하면 버전 증가와 함께 레코드 데이터를 업데이트하게 된다.
  * 업데이트되는 행의 수가 0이면 충돌이 발생한 것이므로 해당 트랜잭션은 롤백하거나 문제를 해결한 후에 다시 시도해야 한다.
* 낙관적 검사에 버전 번호 대신 수정 타임스탬프를 사용하려는 것은 좋지 않다.
  * 시스템 클록은 신뢰할 수 없으며, 특히 여러 서버 간에 작업을 조율하는 경우 더욱 신뢰하기 어렵기 때문이다.
* 버저닝을 통한 낙관적 오프라인 잠금으로 일관성 없는 읽기의 문제가 완전히 해결되지는 않는다.
  * 청구서와 소비세를 계산하는 예시
    * A 세션이 청구서를 생성하고 세금을 계산하기 위해 해당 고객의 주소를 조회
    * A 세션이 고객의 주소를 조회하고 트랜잭션을 수행하는 동안 B 세션에서 해당 고객의 주소를 변경
    * 세율은 고객의 주소지에 따라 다른 경우에 A 세션은 고객의 주소를 변경하지 않았으므로 충돌은 감지되지 않고, 잘못된 세율이 계산됨
  * 위 예시의 문제를 해결하기 위해서는 고객의 주소 값이 중요하다는 것을 인식해야 한다.
  * 따라서 주소를 변경 집합에 추가하거나 버전 검사를 수행할 항목의 목록을 별도로 유지하는 등의 방법으로 주소에 대한 버전 검사를 수행해야 한다.
  * 만약 인공적인 업데이트가 아니라 버전을 다시 읽는 방법으로 일관된 읽기를 검사하는 경우 시스템 트랜잭션 격리 수준에 주의해야 한다.
  * 버전 다시 읽기는 반복 가능 읽기 이상의 경리 수준에서만 작동한다.
* 낙관적 오프라인 잠금만으로 비즈니스 애플리케이션의 모든 까다로운 동시성 또는 일시적 문제를 해결할 수 있는 것은 아니다.
  * 비즈니스 애플리케이션의 동시성 관리는 기술적 문제이기도 하지만 동시에 도메인 문제이기도 하다.
  * 두 세션이 동시에 컬렉션 항목에 추가할 경우에도 비즈니스 규칙을 위반할 가능성이 높다. 일반적인 낙관적 오프라인 잠금 체계에서는 이를 예방하지 못한다.

### 사용 시점
* 두 비즈니스 트랜잭션 간에 충돌이 발생할 가능성이 낮은 경우 유용하다.
* 충돌 가능성이 높거나 충돌의 결과를 받아들일 수 없는 경우 비관적 오프라인 잠금을 사용하는 것이 좋다.
* 낙관적 잠금은 구현하기가 훨씬 쉬우며 비관적 오프라인 잠금과 다르게 결함이나 런타임 오류에 취약하지 않으므로 모든 시스템의 비즈니스 트랜잭션 충돌을 관리하는 기본적인 방식으로 먼저 고려할 수 있다.
* 비관적 잠금은 낙관적 잠금을 보완하는 방식으로 잘 작동하므로 어떤 경우에 낙관적 잠금을 사용해 충돌을 방지할지 고려하기보다는 어떤 경우에 낙관적 잠금만으로는 부족한지 고려하는 것이 좋다.

## 비관적 오프라인 잠금
* 한 시점에 한 트랜잭션만 접근할 수 있게 해서 동시 비즈니스 트랜잭션 간 충돌을 방지한다.
* 작업을 시작할 때 대상 데이터에 대한 잠금을 획득함으로써 일단 비즈니스 트랜잭션을 시작하면 동시성 제어 문제 때문에 작업이 실패하는 경우가 거의 없음을 확신할 수 있다.

### 작동 원리
* 비관적 오프라인 잠금은 잠금 유형 결정, 잠금 관리자 작성, 잠금을 사용할 비즈니스 트랜잭션 절차를 정의하는 세 단계로 구현한다.
* 잠금 유형
  * 배타적 쓰기 잠금 (exclusive write lock)
    * 세션 데이터를 편집하려는 경우에만 비즈니스 트랜잭션이 잠금을 얻도록 요구한다.
    * 이 잠금 체계에서는 데이터 읽기와 관련된 문제는 무시한다. 따라서 뷰 세션이 반드시 최신 데이터를 읽어야 하는 경우가 아니면 이 전략을 사용해도 충분하다.
  * 배타적 읽기 잠금 (exclusive read lock)
    * 비즈니스 트랜잭션에서 편집할지 여부와는 관계없이 항상 최신 데이터를 읽어야 하는 경우 배타적 읽기 잠금을 사용한다.
    * 비즈니스 트랜잭션이 레코드를 로드하려는 경우에도 잠금을 얻도록 요구한다.
    * 이 전략은 시스템의 동시성을 심각하게 제한할 가능성이 있다.
  * 읽기/쓰기 잠금 (read/write lock)
    * 읽기 잠금과 쓰기 잠금은 상호 배타적이다.
    * 다른 비즈니스 트랜잭션이 읽기 잠금을 보유한 레코드에 대해서는 쓰기 잠금을 얻을 수 없다.
    * 다른 비즈니스 트랜잭션이 쓰기 잠금을 보유한 레코드에 대해서는 읽기 잠금을 얻을 수 없다.
    * 동시에 읽기 잠금은 허용된다.
  * 잠금 유형을 결정하고 나면 잠금 관리자를 정의한다.
    * 잠금 관리자의 역할은 잠금을 획득 또는 해제하려는 비즈니스 트랜잭션의 요청을 허용 또는 거부하는 것이다.
* 잠금 해체에 대한 가장 간단한 규칙은 비즈니스 트랜잭션이 완료되면 잠금을 해제하는 것이다.
* 잠금을 획득할 수 없는 비즈니스 트랜잭션에 대한 가장 쉬운 대응은 작업을 취소하는 것이다.
  * 비관적 오프라인 잠금에서는 트랜잭션 초기에 실패하므로 사용자가 큰 거부감 없이 받아들일 수 있다.
* 가능하면 사용자가 작업을 시작하기 전에 모든 잠금을 획득하는 것이 좋다.
* 잠금을 사용할 수 없으면 잠금 관리자가 예외를 발생시키게 함으로써 교착 상태를 해결해야 하는 부담을 줄일 수 있다.

### 사용 시점
* 동시 세션 간의 충돌 가능성이 높은 경우 비관적 오프라인 잠금을 사용하는 것이 좋다.
* 충돌 발생 가능성과 관계없이 충돌이 발생했을 때의 비용이 너무 높은 경우에도 잠금을 사용해야 한다.
