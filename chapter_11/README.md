# Chapter 11. 객체-관계형 동작 패턴
- - -

## 작업 단위
* 객체 모델이 변경될 때마다 데이터베이스를 변경하면 잦은 빈도로 데이터베이스 호출을 해야하기 때문에 부하가 발생할 수 있다.
* 일관성 없는 읽기를 방지하기 위해 읽은 객체를 추적해야 하는 경우 문제가 복잡해진다.
* 작업 단위는 비즈니스 트랜잭션의 영향을 받은 객체의 리스트를 유지 관리하고, 변경 내용을 기록하는 일과 동시성 문제를 해결하는 일을 조율한다.

### 작동 원리
* 새로운 객체를 만들거나 기존 객체를 업데이트 또는 삭제하면 이러한 변경 내용을 데이터베이스에 기록한다.
* 작업 단위에서 가장 중요한 점은 커밋할 시점이 되면 무엇을 해야 하는지 작업 단위가 직접 결정한다는 것이다.
* 트랜잭션을 열고 동시성 검사를 한 다음 변경 내용을 데이터베이스에 기록한다.
* 호출자 등록은 객체의 호출자가 객체를 작업 단위에 등록하는 방식이다.
  * 등록하지 않은 객체의 변경 내용은 커밋할 때 기록되지 않는다.
* 객체 등록 방식에서는 호출자가 객체를 등록하는 책임을 면제받는다.
  * 일반적으로 등록 메서드를 객체 메서드에 넣는다.
  * 객체 개발자는 적절한 위치에서 등록 메서드를 호출해야 하므로 버그가 발생하지 않도록 주의해야 한다.
* 코드 생성을 활용하면 등록 메서드를 호출하는 코드를 자동으로 생성할 수 있지만 이 기법은 생성된 코드와 생성되지 않는 코드를 명확하게 분리할 수 있는 경우에만 사용할 수 있다.
  * 이 문제는 AOP로 해결할 수 있다.
* 객체는 자신의 현재 작업 단위를 찾을 수 있어야 하며, 두 개 이상의 스레드가 하나의 작업 단위에 접근하지 못하게 해야한다.

### 사용 시점
* 작업 단위는 우리가 조작한 다양한 객체를 추적해서 나중에 어떤 객체를 데이터베이스와 동기화해야 하는지 알 수 있게 해주며, 이것이 작업 단위의 가장 중요한 역할이다.
* 하나의 시스템 트랜잭션 안에서 필요한 작업을 모두 할 수 있다면, 수정하는 객체에 대해서만 신경 쓰면 된다.
* 모든 업데이트를 마지막으로 연기하면 과도한 데이터베이스 호출을 방지할 수 있다.
* 객체를 변수에 저장하는 방법 외에도 객체가 변경될 때 설정하는 더티 플래그를 각 객체에 지정하고 트랜잭션이 끝날 때 모든 더티 객체를 확인하고 기록하는 방법이 있다.
* 작업 단위의 가장 중요한 장점은 작업 단위가 모든 정보를 한곳에 모은다는 것이다.
  * 작업 단위가 작동할 수 있게 준비를 완료한 후에는 별다른 일을 하지 않아도 변경 내용을 추적할 수 있다.
* 각 비즈니스 트랜잭션은 단일 스레드 안에서 실행되므로 ThreadLocal 클래스를 사용해서 작업 단위와 현재 실행 중인 스레드를 연결할 수 있다.

## 식별자 맵
* 모든 객체를 한 맵에 로드해 각 객체가 한 번씩만 로드되게 한다. 객체를 참조할 때는 맵을 이용해 객체를 조회한다.
* 식별자 맵은 단일 비즈니스 트랜잭션이 데이터베이스에서 읽은 모든 객체에 대한 기록을 보관한다.
* 객체가 필요할 때마다 먼저 객체가 이미 있는지 여부를 식별자 맵에서 확인한다.

### 작동 원리
* 식별자 맵의 기본 개념은 데이터베이스에서 읽은 객체를 포함하는 일련의 맵을 유지 관리하는 것이다.
* 데이터베이스에서 객체를 로드할 대는 먼저 맵을 확인하고 로드하려는 객체와 일치하는 객체가 맵에 있으면 일치하는 객체를 반환한다.
  * 일치하는 객체가 맵에 없으면 객체를 데이터베이스에서 읽고 향후 참조할 수 있게 맵에 저장한다.
* 식별자 맵은 동시성 관리와 상호작용하므로 낙관적 오프라인 잠금도 고려해야 한다.
* 맵의 키를 무엇을 사용할지 고려가 필요하며, 일반적으로 데이터베이스 테이블의 기본키를 사용한다.
* 식별자 맵을 명시적으로 만들지 또는 범용으로 만들지 선택해야 한다.
  * 명시적 식별자 맵은 필요한 각 종류의 객체에 대해 고유한 메서드를 통해 접근한다.
  * 범용 맵은 필요한 객체의 종류를 매개변수 등을 통해 지정하고 단일 메서드를 통해 모든 종류의 객체에 접근한다.
* 명시적 식별자 맵은 명시적 인터페이스의 다른 모든 장점을 가지고 있다.
* 범용 맵은 모든 객체가 동일한 형식의 키를 가질 때만 사용할 수 있다.
* 식별자 맵은 세션당 하나씩 사용하는 것이 일반적이다.
* 작업 단위가 있다면 식별자 맵을 저장할 수 있는 최적의 위치다.
* 객체가 수정되지 않는다면 세션 간에 공유하는 것을 크게 걱정할 필요가 없으며, 성능이 중요한 시스템에서는 모든 읽기 전용 데이터를 한 번만 로드하고 전체 프로세스에서 사용하는 것이 큰 도움이 될 수 있다.

### 사용 시점
* 식별자 맵은 데이터베이스에서 가져오고 수정하는 객체를 관리하는 데 사용한다.
* 객체를 관리하는 이유는 인메모리 객체 두 개가 동일한 데이터베이스 레코드와 연결되는 상황을 방지하기 위해서다.

## 지연 로드
* 데이터베이스에서 메모리로 데이터를 로드하는 기능을 만들 때는 원하는 객체를 로드하면서 연관된 객체를 함께 로드하도록 설계하는 것이 좋다.
* 하지만 한 객체를 로드할 때 연관된 객체가 지나치게 많이 로드되고 실제로는 소수의 객체만 필요한 상황에서 오히려 성능이 저하되는 경우게 발생할 수 있다.
* 지연 로드는 이 로딩 프로세스를 일시저긍로 중단하고 객체 구조에 표시를 남겨서 나중에 데이터가 필요할 때 로드할 수 있게 한다.

### 작동 원리
* 지연 로드를 구현하는 주요 방법은 지연 초기화, 가상 프록시, 값 홀더, 고스트 네 가지가 있다.
* 지연 초기화는 필드에 접근할 때 먼저 필드가 null인지 확인하고, 필드가 null이면 필드의 값을 계산한 후 변환한다. 이를 위해서는 필드 자체를 캡슐화해야 한다.
  * 지연 초기화는 간단한 접근법이지만 데이터베이스 간의 의존성을 강제하는 경향이 있다.
* 가상 프록시는 원래 객체처럼 생겼지만 실제로는 아무것도 포함하지 않으며, 해당 메서드 중 하나가 호출돼야 데이터베이스에서 올바른 객체를 로드한다.
* 값 홀더는 다른 객체를 랩핑하는 객체며, 기반 객체를 얻으려면 값 홀더에 값을 요구하면 된다.
* 값 홀더는 처음 접근할 때만 데이터베이스에서 데이터를 가져와서 전달한다.
  * 값 홀더의 단점은 클래스가 값 홀더가 있다는 것을 알아야 한다는 점이다.
* 고스트는 미완성 상태의 실제 객체다. 데이터베이스에서 처음 로드한 객체에는 ID만 포함돼 있지만, 필드에 접근하려고 하면 전체 상태가 로드된다.
* 고스트는 모든 필드가 한 번에 지연 초기화되는 객체이거나, 아니면 객체가 자신에 대한 가상 프록시라고 생각할 수 있다.

### 사용 시점
* 언제 지연 로드를 사용할지 결정하려면 데이터베이스에서 객체를 로드할 때 데이터를 얼마나 많이 가져올지, 그리고 데이터베이스 호출이 얼마나 많이 필요한지 먼저 알아야 한다.
* 성능 관점에서 지연 로드는 데이터를 가져오는 비용을 언제 지불할지 결정하는 것에 해당한다.
  * 한 번의 호출로 필요한 모든 것을 미리 가져오고 준비하는 것이 좋은 경우도 많다.
