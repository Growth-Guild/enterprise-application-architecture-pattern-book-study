# Chapter 03. 관계형 데이터베이스 매핑
- - -

## 아키텍처 패턴
* 행 데이터 게이트웨이는 쿼리에서 반환한 행 하나당 인스턴스 하나를 가진다.
* SQL 접근을 도메인 논리와는 별도로 분리하고 개별 클래스에 배치하는 것이 좋다.
* 클래스를 구성하는 방법으로는 데이터베이스 테이블당 클래스 하나를 가지도록 데이터베이스 테이블의 테이블 구조를 바탕으로 클래스를 구성하는 것이 좋다.

### 게이트웨이
* 행 데이터 게이트웨이
  * 쿼리가 반환하는 각 행마다 인스턴스 하나를 만드는 방법
  * 데이터에 대한 객체지향적 사고방식과 잘 어울린다.
* 레코드 집합
  * 데이터베이스의 테이블식 특성을 흉내 낸 테이블과 행의 범용 자료구조다.
  * 데이터베이스의 각 테이블마다 클래스가 하나만 있으면 된다.
  * 테이블 데이터 게이트웨이는 데이터베이스를 쿼리하고 레코드 집합을 반환하는 메서드를 제공한다.
* 활성 레코드
  * 각 도메인 객체가 직접 데이터베이스 로드와 저장을 수행한다.
* 도메인 논리를 작은 클래스로 팩터링하기 시작하면 도메인 클래스와 테이블의 일대일 매칭이 깨지기 시작하므로, 항상 데이터베이스와 상호작용하지 않고도 도메인 논리를 테스트할 수 있는 방법이 필요하다.
* 데이터 매퍼는 데이터베이스와 도메인 모델이 서로 독립적으로 작동할 수 있게 중간에서 로딩과 저장을 대신 처리한다.
  * 두 계층의 완전한 격리라는 장점을 제공한다.

### 동작 문제
* 동작 문제는 객체가 데이터베이스에 저장 및 로드되는 방법이다.
* 객체를 읽고 수정하는 동안에는 사용하는 데이터베이스의 상태를 일관되게 유지해야 한다.
* 작업 단위는 데이터베이스를 일관되게 유지하는 데 필요한 패턴이다.
* 작업 단위는 데이터베이스 매핑의 컨트롤러로 작동하는 객체라고 생각하면 된다.
  * 작업 단위가 없을 때는 일반적으로 도메인 계층이 컨트롤러 역할을 해서 데이터베이스를 읽고 쓸 시점을 결정한다.
* 작업 단위는 데이터베이스 매핑 컨트롤러의 동작을 별도의 객체로 팩터링해서 만든 것이다.

## 관계 매핑
* 객체와 관계형 데이터베이스는 데이터를 참조하는 방법에 차이가 존재하기 때문에 객체와 테이블 사이에서 자료 구조가 반전되는 현상이 발생한다.
* 참조 방법의 차이를 해결하려면 각 객체의 관계형 식별자를 객체의 식별자 필드로 유자히고 이 값을 조회해 객체 참조와 관계형 키 간의 매핑을 처리해야 한다.
* 관계 매핑에서 컬렉션을 다룰 때 흔히 저지르는 실수 중 하나는 컬렉션 내의 순서에 의존하는 것이다.
  * 순서가 있는 컬렉션은 테스트가 쉬워진다는 장점이 있다.
  * 하지만 관계형 데이터베이스에 저장할 때 순서가 있는 컬렉션을 그대로 유지하기 어렵다는 단점이 있다.
  * 컬렉션을 저장할 때 순서가 없는 집합을 사용하는 것을 고려할 필요가 있다.

## 상속
* SQL에는 상속을 처리하는 표준적인 방법이 없기 때문에 매핑하는 방법이 필요한데, 크게 3가지가 존재한다.
* 단일 테이블 상속
  * 모든 정보를 한 곳에 저장하므로 수정하기 쉽고 조인할 필요가 없다.
  * 크기가 크기 때문에 접근 시 병목현상이 발생할 수 있다.
* 구현 테이블 상속
  * 조인 없이 한 객체를 한 테이블에서 가져올 수 있지만 변경에 취약하다. (상위 클래스가 변경되면 모든 테이블과 매핑 코드를 함께 변경해야한다.)
  * 상위 클래스 테이블에서의 잠금 경합은 감소한다.
* 클래스 테이블 상속
  * 계층의 클래스당 테이블 하나를 사용한다.
  * 클래스와 테이블 간의 관계를 가장 단순하게 저장하지만 단일 객체를 로드하기 위해 여러 번 조인을 수행해야 하므로 일반적으로 성능이 낮다.
