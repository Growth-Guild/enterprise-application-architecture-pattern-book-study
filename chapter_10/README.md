# Chapter 10. 데이터 원본 아키텍처 패턴
- - -

## 테이블 데이터 게이트웨이
* 데이터베이스 테이블에 대한 게이트웨이의 역할을 하는 객체.
* 한 인스턴스가 테이블의 모든 행을 처리한다.
* 테이블 데이터 게이트웨이는 단일 테이블이나 뷰에 접근(선택, 삽입, 갱신, 삭제)하는 모든 SQL을 포함한다.
* 다른 코드는 테이블 데이터 게이트웨이의 메서드를 호출해 데이터베이스와의 모든 상호작용을 수행할 수 있다.

### 작동 원리
* 테이블 데이터 게이트웨이는 일반적으로 데이터베이스에서 데이터를 얻는 여러 검색 메서드와 갱신, 삽입, 삭제 메서드로 구성된 간단한 인터페이스를 가지며, 각 인터페이스는 SQL 호출로 맵핑한다.
* 쿼리로부터 정보를 반환하는 방법으로는 데이터 전송 객체를 사용하는 것이 좋다.
  * 데이터 전송 객체도 생성해야 하는 부담은 있지만 다른 여러 곳에서 사용할 수 있다.

### 사용 시점
* 테이블 데이터 게이트웨이는 테이블 모듈과 잘 어울리며, 테이블 모듈이 작업할 레코드 집합 자료구조를 생성할 수 있다.
* 테이블 데이터 게이트웨이는 행 데이터 게이트웨이와 마찬가지로 트랜잭션 스크립트와 함께 사용하는데 적합하다.
* 테이블 데이터 게이트웨이로 데이터베이스 접근을 캡슐화하면 SQL을 사용해 데이터베이스를 조작할 때와 저장 프로시저를 사용할 때 동일한 인터페이스를 사용할 수 있다는 장점이 있다.

## 행 데이터 게이트웨이
* 데이터 원본의 단일 레코드에 대한 게이트웨이 역할을 하는 객체. (행마다 인스턴스 하나가 사용된다.)
* 데이터베이스 접근 코드를 인메모리 객체에 넣는 방법에는 몇 가지 단점이 있다.
  * 자체 비즈니스 논리가 있는 인메모리 객체에 데이터베이스 조작 코드를 넣으면 객체가 더 복잡해진다.
  * 인메모리 객체가 데이터베이스와 결합되면 모든 데이터베이스 접근 때문에 테스트 실행이 느려지므로 테스트하기가 불편해진다.
  * 여러 데이터베이스에서 SQL의 성가신 작은 차이점을 모두 고려하면서 데이터베이스에 접근해야 할 수 있다.

### 작동 원리
* 행 데이터 게이트웨이는 데이터베이스 행 하나와 같이 정확하게 단일 레코드의 흉내를 내는 객체다.
* 데이터베이스의 각 열은 한 필드가 된다.
* 행 데이터 게이트웨이를 사용할 때는 이 패턴을 생성하는 검색 작업을 어디서 해야 할지 결정해야 한다.
  * 정적 검색기 메서드는 다른 데이터 원본이 필요할 때 다형성을 활용해 검색기 메서드를 대체할 수 없다.
  * 별도의 검색기 전체를 만들어 관계형 데이터베이스의 테이블마다 검색기 클래스 하나와 결과에 대한 게이트웨이 클래스 하나를 사용하는 것이 좋다.
* 행 데이터 게이트웨이와 활성 레코드의 차이는 도메인 논리의 존재 여부이다.
  * 도메인 논리가 있으면 활성 레코드다.

### 사용 시점
* 도메인 모델을 사용할 때는 행 데이터 게이트웨이를 사용하지 않는다. 매핑이 간단할 때는 활성 레코드로 추가적인 코드 계층 없이 동일한 일을 할 수 있다.
* 매핑이 복잡할 때는 자료구조와 도메인 객체 간의 결합을 느슨하게 만들 수 있는 데이터 매퍼가 더 좋은 선택이다.

## 활성 레코드
* 데이터베이스 테이블이나 뷰의 행을 래핑하고, 데이터베이스 접근을 캡슐화하며, 해당 데이터에 대한 도메인 논리를 추가하는 객체다.

### 작동 원리
* 활성 레코드의 핵심은 도메인 모델이며 이 안에서 클래스는 기반 데이터베이스의 레코드 구조와 거의 일치하게 된다.
* 각 활성 레코드는 데이터베이스에 데이터를 거장 및 로드하고 해당 데이터를 대상으로 하는 모든 도메인 논리를 담당한다.
* 활성 레코드는 행 데이터 게이트웨이와 아주 비슷하다.
  * 행 데이터 게이트웨이는 데이터베이스 접근만 포함하지만, 활성 레코드는 데이터 원본과 도메인 논리를 모두 포함한다는 차이가 있다.

### 시용 시점
* 활성 레코드는 생성, 읽기, 갱신, 삭제와 같은 기본적인 도메인 논리를 처리하는 데 적합하다.
* 도메인 모델을 설계하는 초기 단계에는 활성 레코드와 데이터 매퍼 중 하나를 선택하는 것이 중요한 관건이다.
* 활성 레코드의 핵심 장점은 단순성이다.
* 활성 레코드의 문제점은 객체가 데이터베이스 테이블과 일대일로 대응되는 동형 스키마일 때만 잘 작동하고, 객체 설계가 데이터베이스 설계와 결합된다.
* 비즈니스 논리가 복잡해질 경우 객체의 직접 관계, 컬렉션, 상속 등을 사용하고 싶어질 수 있는데, 이럴 때는 데이터 매퍼로 방향을 바꿀 필요가 있다.

## 데이터 매퍼
* 객체와 데이터베이스 사이에서 둘 사이는 물론 매퍼 자체에 대한 독립성을 유지하면서 데이터를 옮기는 매퍼의 한 계층이다.
* 객체와 관계형 데이터베이스가 데이터를 구성하는 메커니즘이 다르기 때문에 이형 스키마가 생긴다.
* 객체가 관계형 데이터베이스 구조에 대해 알고 있으면 한쪽의 변화가 다른 쪽에 영향을 미치게 된다.
* 데이터 매퍼는 객체와 데이터베이스로부터 분리하는 소프트웨어 계층이다.

### 작동 원리
* 데이터 매퍼의 전체 계층은 테스트 용도 또는 단일 도메인 계층이 다른 데이터베이스와 동작할 수 있도록 대체될 수 있다.
* 삽입과 업데이트를 처리하려면 데이터베이스 매핑 계층은 어떤 객체가 변경, 생성, 삭제됐는지 알아내야 하는데, 이 기능은 전체 작업량을 하나의 트랜잭션 프레임워크에 넣는 데도 필요하다.
  * 작업 단위 패턴은 이를 구성하는 좋은 패턴이다.
* 매핑 계층은 지연 로드라는 기법을 사용해 인메모리 객체에 미치는 영향을 최소화하면서 이 작업을 처리할 수 있다.
* 매퍼를 직접 코딩할 때는 각 도메인 클래스나 도메인 계층의 루트마다 하나씩 만드는 것이 좋다.
* 객체를 생성하는 방법에는 두 가지 방법이 있다.
  * 리치 생성자를 사용해 객체를 모든 필수 데이터가 포함된 상태로 생성하는 것이다.
  * 다른 방법은 비어 있는 객체를 생성한 다음 나중에 필수 데이터로 채우는 방법이다.
  * 객체의 다형성을 이용하고자 한다면 팩토리 패턴과 리치 생성자를 함께 이용해도 좋은 방법일 것 같다.

### 사용 시점
* 데이터 매퍼를 사용하는 주된 이유는 데이터베이스 스키마와 객체 모델을 분리해서 발전시킬 수 있기 때문이다.
* 도메인 모델과 함께 사용하여 데이터 매퍼를 사용하면, 테스트 프로세스에서 데이터베이스를 고려할 필요가 없어진다.
