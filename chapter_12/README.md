# Chapter 12. 객체-관계형 구조 패턴

## 식별자 필드
* 인메모리 객체와 데이터베이스 행 간의 식별자를 유지 관리하기 위해 데이터베이스 ID 필드를 저장하는 객체

### 작동 원리
* 데이터베이스의 어떤 종류의 키를 선택하는지 고려해야 하는데, 의미 있는 키와 의미 없는 키 중 어떤 것을 선택해야 한다.
  * 의미 있는 키는 비즈니스 상에서 사용될 수 있는 유의미한 값을 말한다.
  * 의미 없는 키는 비즈니스와 무관하게 생성한 임의의 키를 말한다.
  * 대체적으로는 의미 없는 키를 사용하는 것이 좋다.
* 단순 키와 복합 키 중 어떤 것을 사용할지 선택해야 한다.
  * 단순 키는 데이터베이스 필드 하나만 사용하지만 복합 키는 필드를 두 개 이상 사용한다.
* 키의 형식도 선택해야 한다.
  * 키를 사용하는 일반적인 연산은 동등 검사이므로 동등 연산이 빠른 형식을 선택하는 것이 좋다.
  * 다음으로 중요한 연산은 다음 키를 얻는 것이다. 따라서 크기 비교가 가능한(long과 같은) 키를 선택하는 것이 좋다.
* 키의 크기는 성능에 영향을 줄 수 있으며, 특히 인덱스를 사용할 때는 더 많은 영향을 준다.
* 식별자 필드는 데이터베이스의 키와 형식이 일치하는 필드로 만들면 간단하다.
* 복합 키의 경우에는 키 클래스를 만들어 사용한다.
  * 키 객체는 동등 비교가 되도록 유의해야 한다.
* 객체를 생성하려면 새로운 키가 필요한데, 데이터베이스에서 지원하는 자동 생성 방법이 일반적이고 간단하다.
  * 하지만 자동 생성되는 키의 값을 알아내기 어렵다는 문제가 있다.
* 자동 생성의 대안으로 오라클이 시퀀스와 함께 사용하는 데이터베이스 카운터가 있다.
  * 이는 데이터베이스의 표준은 아니며 일부 데이터베이스에서만 지원하므로 사용하기 전에 스펙을 잘 체크해야 한다.
* GUID는 컴퓨터에서 생성되는 숫자이며, 현존하는 모든 컴퓨터에서 고유성이 보장된다.
  * 하지만 키 문자열이 길다는 단점이 있다.

### 사용 시점
* 식별자 필드는 인메모리 객체와 데이터베이스 행 간의 매핑이 있을 때 사용한다. 일반적으로는 도메인 모델이나 행 데이터 게이트웨이를 사용하는 경우에 해당한다.
* 트랜잭션 스크립트나 테이블 모듈, 데이블 데이터 게이트웨이를 사용할 때는 이 매핑이 필요 없다.

## 외래키 맵핑
* 객체에 있는 데이터는 실행 중인 프로그램의 특정 인스턴스에 한정되므로 원시 데이터 값을 그대로 저장할 수는 없다.
* 객체가 다른 객체 참조의 컬렉션을 가지는 경우네는 관계형 데이터베이스의 제1정규형을 위반하므로 패러다임의 불일치 문제도 발생한다.
* 외래 키 맵핑은 객체 참조를 데이터베이스의 외래 키와 맵핑한다.

### 작동 원리
* 패러다임 불일치 문제는 식별자 필드를 사용하여 해결할 수 있다.
  * 각 객체는 해당 데이터베이스 테이블의 데이터베이스 키를 포함하게 한다.
  * 두 객체가 서로 연관 관계를 통해 연결된 경우 이 연관 관계를 데이터베이스의 외래 키로 대체할 수 있다.
* 컬렉션은 데이터베이스에 저장할 수 없으므로 참조의 방향을 반대로 바꿔야 한다.
  * 부모와 자식 테이블 관계라고 할 때, 자식 테이블에 부모 테이블의 키를 넣어야 한다.
* 컬렉션을 업데이트 시에는 컬렉션이 추가 또는 제거가 될 수 있는데, 이러한 변경 사항을 데이터베이스에 저장하는 방법으로는 3 가지가 있다.
  * 삭제 및 삽입
  * 역참조 추가
  * 컬렉션 차이 비교
* 삭제 및 삽입은 데이터베이스에서 해당 컬렉션을 모두 삭제한 후 다시 삽입하는 방법이다.
  * 구현하기 간단하다는 장점이 있다.
  * 자식 컬렉션이 의존 맵핑을 지원해야 한다는 단점이 있다. (부모가 자식을 소유해야 하며 외부에서 참조할 수 없도록)
* 역참조는 자식에서 부모를 연결하는 링크 역할을 하며, 연결을 양방향으로 만든다.
* 컬렉션 차이를 비교하는 방법은 데이터베이스의 현재 내용과 비교하거나 처음 읽는 내용과 비교하는 두 가지 방법이 있다.
  * 데이터베이스와 차이를 비교하려면 데이터베이스에서 컬렉션을 읽고 이를 부모의 자식 컬렉션과 비교해야 한다.
  * 처음 읽는 내용과 차이를 비교하려면 읽은 내용을 보관해야 하며, 이렇게 하면 데이터베이스 읽기를 줄일 수 있어 바람직하다.
* 작업 단위를 사용하면 새로운 객체가 일단 자동으로 삽입되므로 이 단계가 훨씬 수월하다.
* 링크가 순환되지 않게 주의해야 한다. (순환 참조)
* 순환을 방지하려면 객체를 생성하는 두 가지 방법 중 하나를 선택해야 한다.
  * 일반적으로 객체를 생성하는 메서드는 완전한 형식의 객체를 얻을 수 있게 데이터를 포함하는 것이 좋다.
    * 이 방법을 선택하는 경우 적절한 지점에 지연 로드를 배치해 순환을 끊어야 한다.
  * 비어 있는 객체를 만들고 이를 즉시 식별자 맵에 넣는 방법이 있다.
    * 한 차례 순환하고 객체가 이미 로드되면 순환을 끝낼 수 있게 된다.

### 사용 시점
* 외래키 맵핑은 대부분의 클래스 간 연결에 사용할 수 있지만, 다대다 연결의 경우 적용하기 어렵다.
* 다대다 연결에는 연관 테이블 맵핑을 사용해야 한다.
* 역참조가 없는 컬렉션 필드가 있다면 다수 항목이 있는 쪽에 의존 맵핑을 사용할지 고려해야 하며, 이를 사용한다면 컬렉션을 간소하게 처리할 수 있다.

## 연관 테이블 매핑
* 연관된 테이블에 대한 외래 키를 포함하는 테이블에 연관 관계를 저장한다.
* 객체는 컬렉션을 필드 값로 사용해 다중 값 필드를 상당히 손쉽게 처리할 수 있지만 관계형 데이터베이스에는 이 기능이 없기 때문에 패러다임 불일치 문제가 발생한다.
  * 외래 키 매핑을 활용하여 연관 관계의 단일 값 쪽에서 외래 키를 통해 매핑을 처리할 수 있다.
* 다대다 연관 관계의 경우 외래 키를 포함할 단일 값을 구성할 수 없기 때문에 연관 테이블 매핑을 사용해 다중 값을 이 링크 테이블로 매핑한다.

### 작동 원리
* 연관 테이블 매핑의 기본 개념은 링크 테이블을 사용해 연관 관계를 저장한다는 것이다.
  * 이 테이블은 서로 연결된 두 테이블의 외래 키 ID만 포함하며, 연관된 객체 한 쌍당 한 행을 가진다.
* 링크 테이블에서 데이터를 로드하려면 쿼리를 두 번 해야 한다.
  * 이 체계는 모든 정보가 이미 메모리에 있을 때는 아주 잘 작동하지만, 정보가 메모리에 없으면 N:M 관계에서 링크 테이블에 있는 M의 수 만큼 쿼리를 해야 하는 부담생긴다.
  * 이러한 쿼리의 부담을 덜기 위해서 매핑 작업이 약간 더 복잡해지는 것을 감수하고 M 테이블을 링크 테이블과 조인해 단일 쿼리로 모든 데이터를 가져올 수 있게 만들면 된다.

### 사용 시점
* 연관 테이블 매핑의 가장 표준적인 용도는 사실상 다른 대안이 없는 N:M 연관 관계를 나타내는 것이다.
* 연관 테이블 매핑은 다른 모든 형식의 연관 관계에도 사용할 수 있지만, 외래 키 매핑보다 복잡하고 추가적인 조인이 필요하므로 일반적으로는 올바른 선택이 아니다.
* 그러나 연관 관계가 간단하더라도 연관 테이블 매핑을 사용하는 것이 적당한 두 가지 상황이 있다.
  * 두 가지 모두 스키마를 마음대로 제어할 수 없는 데이터베이스를 사용하는 경우다. (기존 테이블 두 개를 연결해야 하지만, 이러한 테이블에 열을 추가하기는 곤란한 상황인 경우.)
* 평균적인 로딩 코드보다 더 복잡하지만, 이 기법으로 쿼리의 수를 줄일 수 있다.
* 다만 복잡하기 때문에 데이터베이스 상호작용이 느린 경우에 한해 필요할 때만 사용해야 한다.
* 도메인 계층이 복잡한 내용에 관여할 필요 없이, 데이터 매퍼에서 좋은 쿼리를 제공할 수 있다.

## 의존 매핑
* 어떤 객체는 다른 객체의 컨텍스트에 자연스럽게 나타나기도 한다. (ex. 앨범의 트랙은 해당 트랙이 속한 앨범이 로드 되거나 저장될 때마다 함께 로드되거나 저장될 수 있다.)
* 데이터베이스의 다른 테이블에서 참조되지 않는 경우, 앨범 매퍼가 트랙에 대한 매핑까지 처리하게 하면 매핑 절차를 간소화할 수 있다.
* 이를 의존매핑이라고 한다.

### 작동 원리
* 의존 매핑의 기본 개념은 한 클래스(의존자)가 자신의 데이터베이스 지속성을 위해 다른 클래스(소유자)에 의존한다는 것이다.
* 각 의존자의 소유자는 반드시 하나여야 한다.
* 소유자를 로드하면 의존자도 함께 로드되는데, 의존자를 로드하는 부담이 크고 자주 사용되지 않는다면 지연 로드를 사용해 필요할 때까지 의존자를 로드하는 것을 지연할 수 있다.
* 의존자의 중요한 특성은 식별자 필드를 갖지 않는다는 것이며, 따라서 의존자는 식별자 맵에 저장되지 않는다.
  * 나는 상황마다 다르다고 생각한다.
* 의존자는 다른 의존자의 소유자일 수 있다.
  * 여러 의존자로 이뤄진 계층 전체를 주요 소유자 하나가 제어하게 할 수 있다.
* 일반적으로 데이터베이스에서 기본 키에는 소유자의 기본 키를 포함하는 복합 키를 사용하면 편리하다.
  * 객체 그래프가 깊어지면 이렇게 하면 복합키를 가지고 있어야 하는 문제가 있을 수 있다.
* 의존자의 기록과 저장은 소유자가 담당하며, 다른 외부 참조는 없으므로 의존자에 대한 업데이트를 삭제와 삽입으로 해결할 수 있다.

### 사용 시점
* 의존 매핑은 객체를 참조하는 객체가 하나일 때만 사용하며, 보통은 한 객체가 의존자의 컬렉션을 가지는 경우가 많다.
* 의존 매핑은 소유자가 의존자 참조의 컬렉션을 가지지만 역참조가 없는 불편한 상황을 해결하지에 좋은 방법이다.
  * 하지만 JPA에서는 1:N 단방향 관계의 경우에 Insert 시에 불필요한 쿼리가 발생할 수 있다.
* 의존 매핑은 다음 요건이 충족돼야 한다.
  * 의존자의 소유자는 정확히 하나여야 한다.
  * 의존자의 소유자를 제외하고는 다른 객체로부터의 참조가 없어야 한다.
* 의존자 그래프가 커지지 않게 주의하는 것이 좋다.
  * 그래프 외부에서 의존자를 참조하는 것이 불가능하기 때문에 루트 소유자 주변에서 복잡한 조회 체계를 만들어야 하는 경우가 많기 때문이다.

## 포함 값
* 포함 값은 객체의 값을 객체 소유자의 레코드에 있는 필드로 매핑한다.

### 작동 원리
* 소유자 객체를 로드하거나 저장할 때마다 의존 객체를 동시에 로드하거나 저장한다.
* 지속성은 모두 소유자에 의해 처리되므로 의존 클래스는 자체 지속성 메서드를 포함하지 않는다.

### 사용 시점
* 포함 값은 금액이나 날짜 범위와 같은 간단한 값 객체에 대해 가장 적절하게 사용할 수 있다.
* 값 객체는 식별자를 가지지 않으므로 동기화를 유지하기 위한 식별자 맵과 같은 사항에 신경 쓰지 않고 손쉽게 만들고 삭제할 수 있다.
* 일반적으로 포함 값은 참조 객체 간의 연관 관계에서 양쪽 끝이 모두 단일 값(일대일 연관)일 때만 사용한다.
  * 경우에 따라서는 후보 의존자가 여러 개지만 그 수가 적고 고정된 상황에도 사용할 수 있다.

## 직렬화 LOB
* 객체를 지속하는 방법으로 객체 그래프 전체를 한 테이블의 큰 객체(LOB) 하나에 기록하는 직렬화가 있다.
* 직렬화 LOB(Serialized LOB)은 메멘토 패턴의 한 형태다.

### 작동 원리
* 직렬화에는 이진(BLOB)과 텍스트(CLOB)의 두 가지 형식이 있다.
* BLOB의 장점은 플랫폼이 지원하는 경우 프로그래밍하기 쉽고 최소한의 공간을 사용한다는 점이다.
  * 단점은 데이터베이스가 BLOB을 위한 이진 데이터 형식을 지원해야 하며, 객체가 없으면 그래프를 재구성할 수 없으므로 일반적인 조회 방법으로는 필드를 볼 수 없다.
  * 객체의 변경에 있어서 버전 관리가 어렵다.
* 대안은 CLOB을 사용하는 것이다.
* CLOB은 그래프를 필요한 모든 정보가 포함된 텍스트 문자열로 직렬화할 수 있다.
  * 그러나 텍스트 방식은 일반적으로 공간이 더 필요하며, 사용하는 텍스트 형식에 맞는 파서를 직접 만들어야 한다.
  * 이진 직화보다 느릴 가능성이 높다.
* 직렬화 LOB을 사용할 때는 식별자 문제를 알고 있어야 한다.
  * 예를 들어 주문 객체에 고객 세부 정보를 직렬화 LOB을 사용하면 모든 데이터가 복사되므로 업데이트에 문제가 발생한다.
  * 반면 주문할 당시의 고객 데이터의 스냅샷을 저장하려는 경우에는 오히려 좋은 방법일 수 있다.
* 이 패턴을 사용할 때는 데이터 복제 문제에 주의해야 한다.
* 직렬화 LOB 전체가 복제되는 경우보다는 다른 항목과 겹치는 부분이 복제되는 경우가 많다.

### 사용 시점
* 직렬화 LOB은 SQL로 쿼리할 가능성이 거의 없는 객체를 애플리케이션 바깥으로 분리하는 방법이라고 보면 된다.

## 단일 테이블 상속
* 단일 테이블 상속은 상속 구조에서 모든 클래스의 모든 필드를 단일 테이블로 매핑한다.

### 작동 원리
* 상속 매핑 체계에서는 상속 계층에 속한 모든 클래스의 데이터를 모두 한 테이블에 저장한다.
* 각 클래스는 연관된 데이터를 한 테이블 행에 저장한다. 데이터베이스에서 연관 사항이 없는 열은 비어 있게 된다.
* 기본 매핑 동작은 상속 매퍼의 기본 체계를 따른다.
* 객체를 메모리로 로딩할 때는 어떤 클래스를 인스턴스화할지 알아야 한다. 이를 위해 어떤 클래스를 사용할지 표시하는 필드 하나가 테이블에 포함된다.

### 사용 시점
* 단일 테이블 상속은 상속 계층의 필드를 관계형 데이터베이스로 매핑하는 여러 방법 중 하나다.
* 대안으로는 클래스 테이블 상속과 구현 테이블 상속이 있다.
* 단일 테이블 상속은 다음과 같은 장점이 있다.
  * 데이터베이스에서 한 테이블만 사용하면 된다.
  * 데이터를 가져올 때 조인할 필요가 없다.
  * 필드를 계층에서 위아래로 이동하는 리팩터링을 하더라도 데이터베이스를 변경할 필요가 없다.
* 단점은 다음과 같다.
  * 필드에 연관성이 있을 수도 있지만 없을 수도 있다. 이 때문에 테이블을 직접 사용하는 경우 혼란스러울 수 있다.
  * 일부 하위 클래스에만 사용되는 열이 있으면 데이터베이스의 공간이 낭비된다.
  * 단일 테이블이 여러 인덱스를 포함해 지나치게 커지거 잠김이 빈번하게 발생할 수 있으며 성능이 저하될 수 있다.
  * 필드에 단일 네임스페이스가 사용되므로 서로 다른 필드에 동일한 이름을 사용하지 않아야 한다.

## 클래스 테이블 상속
* 알아보기 쉽게 객체와 매핑되며 상속 구조의 어떤 위치로든 연결할 수 있는 데이터베이스 구조가 필요할 때는 상속 구조의 클래스마다 데이터베이스 테이블 하나를 사용하는 클래스 테이블 상속을 사용하면 된다.

### 작동 원리
* 클래스 테이블 상속은 도메인 모델의 클래스당 테이블 하나를 사용하는 명확한 구조를 가지고 있다.
* 도메인 클래스의 각 필드는 해당 테이블의 필드와 일대일로 대응된다.
* 한 가지 중요한 사항은 데이터베이스 테이블의 해당하는 행을 서로 연결하는 방법이다.
  * 한 가지 방법은 공용 기본 키 값을 사용하는 것이다. 상위 클래스 테이블에는 다른 테이블의 각 행에 해당하는 행이 포함되므로 이 체계를 사용하는 경우 기본 키는 전체 테이블에서 고유하다.
  * 다른 방법으로는 각 테이블이 자체적인 기본 키를 갖게 하고 상위 클래스 테이블에 대한 외래 키를 사용해 행을 서로 연결하는 방법이 있다.
* 클래스 테이블 상속을 구현할 때 가장 중요한 점은 여러 테이블의 데이터를 효율적인 방법으로 가져와야 한다는 것이다.
  * 각 테이블을 호출하면 데이터베이스를 여러 번 호출해야 하기 때문이다.
  * 전체 컴포넌트 테이블에 걸쳐 조인하면 이 문제를 해결할 수는 있지만 조인에도 한계가 있다.

### 사용 시점
* 클래스 테이블 상속의 장점
  * 각 행의 모든 열에 의미가 있으므로 테이블 구조를 이해하기 쉽고 공간이 낭비되지 않는다.
  * 도메인 모델과 데이터베이스 간의 관계가 아주 직관적이다.
* 클래스 테이블 상속의 단점
  * 객체 하나를 로드하기 위해 여러 테이블에서 데이터를 읽어야 한다.
  * 필드를 계층에서 위아래로 이동하는 리팩터링을 할 경우 데이터베이스도 변경해야 한다.
  * 자주 접근해야 하는 상위 형식 테이블에서 병목현상이 발생할 수 있다.
  * 정규화 수준이 높아서 임시 쿼리가 이해하기 어려워질 수 있다.
* 한 클래스 계층에 한 상속 매핑 패턴만 선택해야 하는 것은 아니다.
  * 예를 들어, 계층 최상위에는 클래스 테이블 상속을 사용하고 그 아래에는 여러 구현 테이블 상속을 사용할 수 있다.
