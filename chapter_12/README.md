# Chapter 12. 객체-관계형 구조 패턴

## 식별자 필드
* 인메모리 객체와 데이터베이스 행 간의 식별자를 유지 관리하기 위해 데이터베이스 ID 필드를 저장하는 객체

### 작동 원리
* 데이터베이스의 어떤 종류의 키를 선택하는지 고려해야 하는데, 의미 있는 키와 의미 없는 키 중 어떤 것을 선택해야 한다.
  * 의미 있는 키는 비즈니스 상에서 사용될 수 있는 유의미한 값을 말한다.
  * 의미 없는 키는 비즈니스와 무관하게 생성한 임의의 키를 말한다.
  * 대체적으로는 의미 없는 키를 사용하는 것이 좋다.
* 단순 키와 복합 키 중 어떤 것을 사용할지 선택해야 한다.
  * 단순 키는 데이터베이스 필드 하나만 사용하지만 복합 키는 필드를 두 개 이상 사용한다.
* 키의 형식도 선택해야 한다.
  * 키를 사용하는 일반적인 연산은 동등 검사이므로 동등 연산이 빠른 형식을 선택하는 것이 좋다.
  * 다음으로 중요한 연산은 다음 키를 얻는 것이다. 따라서 크기 비교가 가능한(long과 같은) 키를 선택하는 것이 좋다.
* 키의 크기는 성능에 영향을 줄 수 있으며, 특히 인덱스를 사용할 때는 더 많은 영향을 준다.
* 식별자 필드는 데이터베이스의 키와 형식이 일치하는 필드로 만들면 간단하다.
* 복합 키의 경우에는 키 클래스를 만들어 사용한다.
  * 키 객체는 동등 비교가 되도록 유의해야 한다.
* 객체를 생성하려면 새로운 키가 필요한데, 데이터베이스에서 지원하는 자동 생성 방법이 일반적이고 간단하다.
  * 하지만 자동 생성되는 키의 값을 알아내기 어렵다는 문제가 있다.
* 자동 생성의 대안으로 오라클이 시퀀스와 함께 사용하는 데이터베이스 카운터가 있다.
  * 이는 데이터베이스의 표준은 아니며 일부 데이터베이스에서만 지원하므로 사용하기 전에 스펙을 잘 체크해야 한다.
* GUID는 컴퓨터에서 생성되는 숫자이며, 현존하는 모든 컴퓨터에서 고유성이 보장된다.
  * 하지만 키 문자열이 길다는 단점이 있다.

### 사용 시점
* 식별자 필드는 인메모리 객체와 데이터베이스 행 간의 매핑이 있을 때 사용한다. 일반적으로는 도메인 모델이나 행 데이터 게이트웨이를 사용하는 경우에 해당한다.
* 트랜잭션 스크립트나 테이블 모듈, 데이블 데이터 게이트웨이를 사용할 때는 이 매핑이 필요 없다.

## 외래키 맵핑
* 객체에 있는 데이터는 실행 중인 프로그램의 특정 인스턴스에 한정되므로 원시 데이터 값을 그대로 저장할 수는 없다.
* 객체가 다른 객체 참조의 컬렉션을 가지는 경우네는 관계형 데이터베이스의 제1정규형을 위반하므로 패러다임의 불일치 문제도 발생한다.
* 외래 키 맵핑은 객체 참조를 데이터베이스의 외래 키와 맵핑한다.

### 작동 원리
* 패러다임 불일치 문제는 식별자 필드를 사용하여 해결할 수 있다.
  * 각 객체는 해당 데이터베이스 테이블의 데이터베이스 키를 포함하게 한다.
  * 두 객체가 서로 연관 관계를 통해 연결된 경우 이 연관 관계를 데이터베이스의 외래 키로 대체할 수 있다.
* 컬렉션은 데이터베이스에 저장할 수 없으므로 참조의 방향을 반대로 바꿔야 한다.
  * 부모와 자식 테이블 관계라고 할 때, 자식 테이블에 부모 테이블의 키를 넣어야 한다.
* 컬렉션을 업데이트 시에는 컬렉션이 추가 또는 제거가 될 수 있는데, 이러한 변경 사항을 데이터베이스에 저장하는 방법으로는 3 가지가 있다.
  * 삭제 및 삽입
  * 역참조 추가
  * 컬렉션 차이 비교
* 삭제 및 삽입은 데이터베이스에서 해당 컬렉션을 모두 삭제한 후 다시 삽입하는 방법이다.
  * 구현하기 간단하다는 장점이 있다.
  * 자식 컬렉션이 의존 맵핑을 지원해야 한다는 단점이 있다. (부모가 자식을 소유해야 하며 외부에서 참조할 수 없도록)
* 역참조는 자식에서 부모를 연결하는 링크 역할을 하며, 연결을 양방향으로 만든다.
* 컬렉션 차이를 비교하는 방법은 데이터베이스의 현재 내용과 비교하거나 처음 읽는 내용과 비교하는 두 가지 방법이 있다.
  * 데이터베이스와 차이를 비교하려면 데이터베이스에서 컬렉션을 읽고 이를 부모의 자식 컬렉션과 비교해야 한다.
  * 처음 읽는 내용과 차이를 비교하려면 읽은 내용을 보관해야 하며, 이렇게 하면 데이터베이스 읽기를 줄일 수 있어 바람직하다.
* 작업 단위를 사용하면 새로운 객체가 일단 자동으로 삽입되므로 이 단계가 훨씬 수월하다.
* 링크가 순환되지 않게 주의해야 한다. (순환 참조)
* 순환을 방지하려면 객체를 생성하는 두 가지 방법 중 하나를 선택해야 한다.
  * 일반적으로 객체를 생성하는 메서드는 완전한 형식의 객체를 얻을 수 있게 데이터를 포함하는 것이 좋다.
    * 이 방법을 선택하는 경우 적절한 지점에 지연 로드를 배치해 순환을 끊어야 한다.
  * 비어 있는 객체를 만들고 이를 즉시 식별자 맵에 넣는 방법이 있다.
    * 한 차례 순환하고 객체가 이미 로드되면 순환을 끝낼 수 있게 된다.

### 사용 시점
* 외래키 맵핑은 대부분의 클래스 간 연결에 사용할 수 있지만, 다대다 연결의 경우 적용하기 어렵다.
* 다대다 연결에는 연관 테이블 맵핑을 사용해야 한다.
* 역참조가 없는 컬렉션 필드가 있다면 다수 항목이 있는 쪽에 의존 맵핑을 사용할지 고려해야 하며, 이를 사용한다면 컬렉션을 간소하게 처리할 수 있다.

## 연관 테이블 매핑
* 연관된 테이블에 대한 외래 키를 포함하는 테이블에 연관 관계를 저장한다.
* 객체는 컬렉션을 필드 값로 사용해 다중 값 필드를 상당히 손쉽게 처리할 수 있지만 관계형 데이터베이스에는 이 기능이 없기 때문에 패러다임 불일치 문제가 발생한다.
  * 외래 키 매핑을 활용하여 연관 관계의 단일 값 쪽에서 외래 키를 통해 매핑을 처리할 수 있다.
* 다대다 연관 관계의 경우 외래 키를 포함할 단일 값을 구성할 수 없기 때문에 연관 테이블 매핑을 사용해 다중 값을 이 링크 테이블로 매핑한다.

### 작동 원리
* 연관 테이블 매핑의 기본 개념은 링크 테이블을 사용해 연관 관계를 저장한다는 것이다.
  * 이 테이블은 서로 연결된 두 테이블의 외래 키 ID만 포함하며, 연관된 객체 한 쌍당 한 행을 가진다.
* 링크 테이블에서 데이터를 로드하려면 쿼리를 두 번 해야 한다.
  * 이 체계는 모든 정보가 이미 메모리에 있을 때는 아주 잘 작동하지만, 정보가 메모리에 없으면 N:M 관계에서 링크 테이블에 있는 M의 수 만큼 쿼리를 해야 하는 부담생긴다.
  * 이러한 쿼리의 부담을 덜기 위해서 매핑 작업이 약간 더 복잡해지는 것을 감수하고 M 테이블을 링크 테이블과 조인해 단일 쿼리로 모든 데이터를 가져올 수 있게 만들면 된다.

### 사용 시점
* 연관 테이블 매핑의 가장 표준적인 용도는 사실상 다른 대안이 없는 N:M 연관 관계를 나타내는 것이다.
* 연관 테이블 매핑은 다른 모든 형식의 연관 관계에도 사용할 수 있지만, 외래 키 매핑보다 복잡하고 추가적인 조인이 필요하므로 일반적으로는 올바른 선택이 아니다.
* 그러나 연관 관계가 간단하더라도 연관 테이블 매핑을 사용하는 것이 적당한 두 가지 상황이 있다.
  * 두 가지 모두 스키마를 마음대로 제어할 수 없는 데이터베이스를 사용하는 경우다. (기존 테이블 두 개를 연결해야 하지만, 이러한 테이블에 열을 추가하기는 곤란한 상황인 경우.)
* 평균적인 로딩 코드보다 더 복잡하지만, 이 기법으로 쿼리의 수를 줄일 수 있다.
* 다만 복잡하기 때문에 데이터베이스 상호작용이 느린 경우에 한해 필요할 때만 사용해야 한다.
* 도메인 계층이 복잡한 내용에 관여할 필요 없이, 데이터 매퍼에서 좋은 쿼리를 제공할 수 있다.

## 의존 매핑
* 어떤 객체는 다른 객체의 컨텍스트에 자연스럽게 나타나기도 한다. (ex. 앨범의 트랙은 해당 트랙이 속한 앨범이 로드 되거나 저장될 때마다 함께 로드되거나 저장될 수 있다.)
* 데이터베이스의 다른 테이블에서 참조되지 않는 경우, 앨범 매퍼가 트랙에 대한 매핑까지 처리하게 하면 매핑 절차를 간소화할 수 있다.
* 이를 의존매핑이라고 한다.

### 작동 원리
* 의존 매핑의 기본 개념은 한 클래스(의존자)가 자신의 데이터베이스 지속성을 위해 다른 클래스(소유자)에 의존한다는 것이다.
* 각 의존자의 소유자는 반드시 하나여야 한다.
* 소유자를 로드하면 의존자도 함께 로드되는데, 의존자를 로드하는 부담이 크고 자주 사용되지 않는다면 지연 로드를 사용해 필요할 때까지 의존자를 로드하는 것을 지연할 수 있다.
* 의존자의 중요한 특성은 식별자 필드를 갖지 않는다는 것이며, 따라서 의존자는 식별자 맵에 저장되지 않는다.
  * 나는 상황마다 다르다고 생각한다.
* 의존자는 다른 의존자의 소유자일 수 있다.
  * 여러 의존자로 이뤄진 계층 전체를 주요 소유자 하나가 제어하게 할 수 있다.
* 일반적으로 데이터베이스에서 기본 키에는 소유자의 기본 키를 포함하는 복합 키를 사용하면 편리하다.
  * 객체 그래프가 깊어지면 이렇게 하면 복합키를 가지고 있어야 하는 문제가 있을 수 있다.
* 의존자의 기록과 저장은 소유자가 담당하며, 다른 외부 참조는 없으므로 의존자에 대한 업데이트를 삭제와 삽입으로 해결할 수 있다.

### 사용 시점
* 의존 매핑은 객체를 참조하는 객체가 하나일 때만 사용하며, 보통은 한 객체가 의존자의 컬렉션을 가지는 경우가 많다.
* 의존 매핑은 소유자가 의존자 참조의 컬렉션을 가지지만 역참조가 없는 불편한 상황을 해결하지에 좋은 방법이다.
  * 하지만 JPA에서는 1:N 단방향 관계의 경우에 Insert 시에 불필요한 쿼리가 발생할 수 있다.
* 의존 매핑은 다음 요건이 충족돼야 한다.
  * 의존자의 소유자는 정확히 하나여야 한다.
  * 의존자의 소유자를 제외하고는 다른 객체로부터의 참조가 없어야 한다.
* 의존자 그래프가 커지지 않게 주의하는 것이 좋다.
  * 그래프 외부에서 의존자를 참조하는 것이 불가능하기 때문에 루트 소유자 주변에서 복잡한 조회 체계를 만들어야 하는 경우가 많기 때문이다.