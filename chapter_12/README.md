# Chapter 12. 객체-관계형 구조 패턴

## 식별자 필드
* 인메모리 객체와 데이터베이스 행 간의 식별자를 유지 관리하기 위해 데이터베이스 ID 필드를 저장하는 객체

### 작동 원리
* 데이터베이스의 어떤 종류의 키를 선택하는지 고려해야 하는데, 의미 있는 키와 의미 없는 키 중 어떤 것을 선택해야 한다.
  * 의미 있는 키는 비즈니스 상에서 사용될 수 있는 유의미한 값을 말한다.
  * 의미 없는 키는 비즈니스와 무관하게 생성한 임의의 키를 말한다.
  * 대체적으로는 의미 없는 키를 사용하는 것이 좋다.
* 단순 키와 복합 키 중 어떤 것을 사용할지 선택해야 한다.
  * 단순 키는 데이터베이스 필드 하나만 사용하지만 복합 키는 필드를 두 개 이상 사용한다.
* 키의 형식도 선택해야 한다.
  * 키를 사용하는 일반적인 연산은 동등 검사이므로 동등 연산이 빠른 형식을 선택하는 것이 좋다.
  * 다음으로 중요한 연산은 다음 키를 얻는 것이다. 따라서 크기 비교가 가능한(long과 같은) 키를 선택하는 것이 좋다.
* 키의 크기는 성능에 영향을 줄 수 있으며, 특히 인덱스를 사용할 때는 더 많은 영향을 준다.
* 식별자 필드는 데이터베이스의 키와 형식이 일치하는 필드로 만들면 간단하다.
* 복합 키의 경우에는 키 클래스를 만들어 사용한다.
  * 키 객체는 동등 비교가 되도록 유의해야 한다.
* 객체를 생성하려면 새로운 키가 필요한데, 데이터베이스에서 지원하는 자동 생성 방법이 일반적이고 간단하다.
  * 하지만 자동 생성되는 키의 값을 알아내기 어렵다는 문제가 있다.
* 자동 생성의 대안으로 오라클이 시퀀스와 함께 사용하는 데이터베이스 카운터가 있다.
  * 이는 데이터베이스의 표준은 아니며 일부 데이터베이스에서만 지원하므로 사용하기 전에 스펙을 잘 체크해야 한다.
* GUID는 컴퓨터에서 생성되는 숫자이며, 현존하는 모든 컴퓨터에서 고유성이 보장된다.
  * 하지만 키 문자열이 길다는 단점이 있다.

### 사용 시점
* 식별자 필드는 인메모리 객체와 데이터베이스 행 간의 매핑이 있을 때 사용한다. 일반적으로는 도메인 모델이나 행 데이터 게이트웨이를 사용하는 경우에 해당한다.
* 트랜잭션 스크립트나 테이블 모듈, 데이블 데이터 게이트웨이를 사용할 때는 이 매핑이 필요 없다.

## 외래키 맵핑
* 객체에 있는 데이터는 실행 중인 프로그램의 특정 인스턴스에 한정되므로 원시 데이터 값을 그대로 저장할 수는 없다.
* 객체가 다른 객체 참조의 컬렉션을 가지는 경우네는 관계형 데이터베이스의 제1정규형을 위반하므로 패러다임의 불일치 문제도 발생한다.
* 외래 키 맵핑은 객체 참조를 데이터베이스의 외래 키와 맵핑한다.

### 작동 원리
* 패러다임 불일치 문제는 식별자 필드를 사용하여 해결할 수 있다.
  * 각 객체는 해당 데이터베이스 테이블의 데이터베이스 키를 포함하게 한다.
  * 두 객체가 서로 연관 관계를 통해 연결된 경우 이 연관 관계를 데이터베이스의 외래 키로 대체할 수 있다.
* 컬렉션은 데이터베이스에 저장할 수 없으므로 참조의 방향을 반대로 바꿔야 한다.
  * 부모와 자식 테이블 관계라고 할 때, 자식 테이블에 부모 테이블의 키를 넣어야 한다.
* 컬렉션을 업데이트 시에는 컬렉션이 추가 또는 제거가 될 수 있는데, 이러한 변경 사항을 데이터베이스에 저장하는 방법으로는 3 가지가 있다.
  * 삭제 및 삽입
  * 역참조 추가
  * 컬렉션 차이 비교
* 삭제 및 삽입은 데이터베이스에서 해당 컬렉션을 모두 삭제한 후 다시 삽입하는 방법이다.
  * 구현하기 간단하다는 장점이 있다.
  * 자식 컬렉션이 의존 맵핑을 지원해야 한다는 단점이 있다. (부모가 자식을 소유해야 하며 외부에서 참조할 수 없도록)
* 역참조는 자식에서 부모를 연결하는 링크 역할을 하며, 연결을 양방향으로 만든다.
* 컬렉션 차이를 비교하는 방법은 데이터베이스의 현재 내용과 비교하거나 처음 읽는 내용과 비교하는 두 가지 방법이 있다.
  * 데이터베이스와 차이를 비교하려면 데이터베이스에서 컬렉션을 읽고 이를 부모의 자식 컬렉션과 비교해야 한다.
  * 처음 읽는 내용과 차이를 비교하려면 읽은 내용을 보관해야 하며, 이렇게 하면 데이터베이스 읽기를 줄일 수 있어 바람직하다.
* 작업 단위를 사용하면 새로운 객체가 일단 자동으로 삽입되므로 이 단계가 훨씬 수월하다.
* 링크가 순환되지 않게 주의해야 한다. (순환 참조)
* 순환을 방지하려면 객체를 생성하는 두 가지 방법 중 하나를 선택해야 한다.
  * 일반적으로 객체를 생성하는 메서드는 완전한 형식의 객체를 얻을 수 있게 데이터를 포함하는 것이 좋다.
    * 이 방법을 선택하는 경우 적절한 지점에 지연 로드를 배치해 순환을 끊어야 한다.
  * 비어 있는 객체를 만들고 이를 즉시 식별자 맵에 넣는 방법이 있다.
    * 한 차례 순환하고 객체가 이미 로드되면 순환을 끝낼 수 있게 된다.

### 사용 시점
* 외래키 맵핑은 대부분의 클래스 간 연결에 사용할 수 있지만, 다대다 연결의 경우 적용하기 어렵다.
* 다대다 연결에는 연관 테이블 맵핑을 사용해야 한다.
* 역참조가 없는 컬렉션 필드가 있다면 다수 항목이 있는 쪽에 의존 맵핑을 사용할지 고려해야 하며, 이를 사용한다면 컬렉션을 간소하게 처리할 수 있다.
